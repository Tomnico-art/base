# c/c++基础

## 1、多态的实现

多态是面向对象编程中的一个重要概念，它指的是通过一个基类指针或引用调用一个虚函数时，会根据具体对象的类型来调用该虚函数的不同实现。在多态中，相同的操作可以作用于不同的对象，而具体执行的操作则取决于对象的类型和特性。

在C++中，**通过将基类中的成员函数声明为虚函数**，即可实现多态。具体实现步骤如下：

1. 在基类中声明一个虚函数。该虚函数必须在子类中被覆盖。
2. 在子类中实现该虚函数，并使用关键字“override”来显式地表示该函数是虚函数的一个覆盖实现。
3. 在使用基类指针或引用调用该虚函数时，会根据实际对象的类型来选择调用相应的子类实现。

```c++
#include <iostream>

using namespace std;

class Animal {
public:
    virtual void speak() {
        cout << "I am an animal." << endl;
    }
};

class Cat : public Animal {
public:
    void speak() override {
        cout << "I am a cat." << endl;
    }
};

class Dog : public Animal {
public:
    void speak() override {
        cout << "I am a dog." << endl;
    }
};

int main() {
    Animal *animal;
    Cat cat;
    Dog dog;

    animal = &cat;
    animal->speak();  // 输出：I am a cat.

    animal = &dog;
    animal->speak();  // 输出：I am a dog.

    return 0;
}
```

在上述示例中，Animal类是基类，Cat和Dog类是继承自Animal的子类。在Animal中定义了一个虚函数speak，该函数在子类中被覆盖。在main函数中，首先将animal指针指向一个Cat对象，然后调用speak函数，会输出"I am a cat."，接着将animal指针指向一个Dog对象，再次调用speak函数，会输出"I am a dog."，实现了多态的效果。

## 2、说说C/C++的区别

`C++`是`C`的超集，也就是说，`C++`包括了`C`的所有基础特性，并且还增加了一些新的特性。下面列举一些`C`和`C++`之间的主要区别：

* 面向对象编程

`C++` 是一种面向对象的编程语言，而 `C` 不是。因此，`C++` 支持类、继承、封装、多态等一系列面向对象的概念和特性，这些能力使 `C++` 更加灵活和强大。

* 标准库

`C++` 标准库比 `C` 标准库更加完善和强大。`C++` 标准库包括了很多容器类，如 `vector`、`map`、`set` 等，以及输入输出流、字符串处理等常用功能。这些库函数可以在许多情况下提高开发效率。

* 命名空间

`C++` 引入了命名空间的概念，可以避免函数命名相同的冲突。使用命名空间可以将代码按照逻辑分组，并更好地组织代码。

* 异常处理

`C++` 支持异常处理机制，这个机制可以增强程序的容错性和可靠性。当程序发生异常时，可以抛出异常并在可控范围内进行处理，避免程序崩溃。而 `C` 不支持异常处理机制。

* 运算符重载

`C++` 允许对运算符进行重载，可以使得运算符在处理特定类型的数据时更具有描述性。而 `C` 不支持运算符重载。什么是指针？

指针是`C++`中的一种数据类型，指针变量存储了一个内存地址，该地址指向某个变量或者对象。指针可以用来访问和修改内存中的数据，同时也可以通过指针来传递参数和返回值。对于`C++`程序员来说，精通指针的使用是非常重要的。

## 3、说说malloc/free 和 new/delete区别

### **malloc和new的区别**

`malloc`和`new`都是用于动态分配内存的函数，但它们在使用方法和效果上有一些区别：

* 调用方式不同：`malloc`是`C`语言标准库中的函数，需要以函数调用形式调用，并且需要指定要分配的内存大小。而`new`是`C++`关键字，在使用时直接在类型后面添加括号即可，无需显式地指定内存大小。
* 内存分配方式不同：`malloc`只负责分配内存空间，并返回该内存空间的起始地址，但不会进行初始化。而`new`除了分配内存空间外，还会自动调用构造函数对对象进行初始化。
* 返回值类型不同：`malloc`返回`void`类型的指针，需要进行强制类型转换，才能够使用；而`new`返回一个指向已分配内存空间的指针，且不需要进行强制类型转换。
* 内存分配失败时的处理方式不同：当内存分配失败时，`malloc`会返回`NULL`，并需要手动释放已经分配的内存空间；而`new`会抛出`std::badalloc`异常，程序可以通过异常捕获机制来处理。

### **delete和free区别**

`delete`和`free`都可以用于释放动态分配的内存，但是它们之间有以下几点区别：

* `delete`是`C++`中的运算符，而`free`是`C`语言中的函数。
* `delete`会自动调用对象的析构函数来清理资源；而`free`只是简单地释放指针所指向的内存块。
* `delete`必须要用于`new`动态分配的内存；而`free`必须要用于`malloc`动态分配的内存。

因此，在`C++`中应该使用`delete`来释放内存，而不是使用`free`。

## 4、 C/C++引用和指针的区别？

指针是一个实体，需要分配内存空间；引用只是变量的别名，不需要分配内存空间。引用在定义的时候必须进行初始化，并且不能够改变；指针在定义的时候不一定要初始化，并且指向的空间可变。有多级指针，但是没有多级引用，只能有一级引用。指针和引用的自增运算结果不一样。

## 5、 const和static

const修饰成员变量：变成常量，不能被修改

const修饰成员函数：成员函数中的变量不能被修改


## 6、程序什么时候应该使用线程，什么时候单线程效率高

1 耗时的操作使用线程，提高应用程序响应

2 并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求。

3 多CPU系统中，使用线程提高CPU利用率

4 改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。

其他情况都使用单线程。


